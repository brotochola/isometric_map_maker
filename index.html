<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Isometric Map Maker</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #toolbar {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border-bottom: 3px solid #3498db;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        #toolbar input[type="file"] {
            display: none;
        }

        #toolbar button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #toolbar button:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        #toolbar button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #toolbar .export-group button {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        #toolbar .export-group button:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
        }

        #toolbar input[type="range"] {
            width: 80px;
            margin: 0 5px;
        }

        #toolbar input[type="number"] {
            background: #34495e;
            color: white;
            border: 1px solid #556983;
            border-radius: 4px;
            padding: 4px 6px;
            width: 60px;
        }

        #toolbar label {
            color: #ecf0f1;
            font-weight: 500;
            font-size: 13px;
            margin-left: 12px;
        }

        #toolbar label:first-of-type {
            margin-left: 0;
        }

        #toolbar span {
            color: #bdc3c7;
            margin-right: 8px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 8px;
            border-right: 1px solid #556983;
        }

        .toolbar-section:last-child {
            border-right: none;
        }

        #editor {
            position: relative;
            width: 1000vw;
            height: 1000vh;

            overflow: visible;
            background: #f0f0f0;
            border-top: 1px solid #aaa;
        }

        #editor-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 40px);
            overflow: hidden;
            background: #f0f0f0;
            border-top: 1px solid #aaa;
        }

        #editor-container.panning {
            cursor: grab;
        }

        #editor-container.panning:active {
            cursor: grabbing;
        }

        .item {
            border: 1px solid transparent;
            box-sizing: content-box;
            position: absolute;
            cursor: move;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;

            pointer-events: auto;
        }

        .guide-line {
            position: absolute;
            width: 2px;
            background-color: rgba(0, 0, 255, 0.5);
            opacity: 0.8;
            pointer-events: none;
            z-index: 9999;
            transform-origin: center center;
            display: none;

        }

        .h-guide-line {
            position: absolute;
            height: 2px;
            background-color: rgba(0, 0, 255, 0.5);
            opacity: 0.8;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }


        .item:hover {
            border: 1px solid rgba(0, 0, 255, 0.5);
        }

        /* When an item is pinned to background, show yellow bounding box on hover */
        .item.background:hover {
            border: 1px solid yellow;
        }
    </style>
</head>
<body>

    <div id="toolbar">
        <!-- Hidden file inputs -->
        <input type="file" id="fileInput" multiple accept="image/*">
        <input type="file" id="tilingInput" accept="image/*">
        <input type="file" id="loadSceneInput" multiple accept=".json,image/*">

        <!-- File operations section -->
        <div class="toolbar-section">
            <button onclick="document.getElementById('fileInput').click()">üìÅ Add Images</button>
            <button id="tilingBtn">üñºÔ∏è Add Background</button>
            <button id="loadSceneBtn">üìÇ Load Scene</button>
        </div>

        <!-- Export section -->
        <div class="toolbar-section export-group">
            <button id="exportWithoutAssetsBtn">üìÑ Export JSON</button>
            <button id="exportWithAssetsBtn">üì¶ Export JSON + Assets</button>
        </div>

        <!-- Grid controls section -->
        <div class="toolbar-section">
            <label for="angleSlider">Grid Angle:</label>
            <input type="range" id="angleSlider" min="45" max="90" value="60" step="0.1">
            <input type="number" id="angleInput" min="45" max="90" value="60" step="0.1">
            <span>¬∞</span>

            <label for="gridSizeSlider">Grid Size:</label>
            <input type="range" id="gridSizeSlider" min="10" max="120" value="80" step="1">
            <input type="number" id="gridSizeInput" min="10" max="120" value="80" step="1">
            <span>px</span>
        </div>

        <!-- Grid visibility section -->
        <div class="toolbar-section">
            <label for="gridCheckbox">
                <input type="checkbox" id="gridCheckbox"> Show Grid
            </label>
        </div>
    </div>

    <div id="editor-container">
        <div id="editor"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const editorContainer = document.getElementById('editor-container');
        const fileInput = document.getElementById('fileInput');
        const tilingInput = document.getElementById('tilingInput');
        const tilingBtn = document.getElementById('tilingBtn');
        const loadSceneInput = document.getElementById('loadSceneInput');
        const loadSceneBtn = document.getElementById('loadSceneBtn');
        const exportWithAssetsBtn = document.getElementById('exportWithAssetsBtn');
        const exportWithoutAssetsBtn = document.getElementById('exportWithoutAssetsBtn');
        const angleSlider = document.getElementById('angleSlider');
        const angleInput = document.getElementById('angleInput');
        const gridSizeSlider = document.getElementById('gridSizeSlider');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridCheckbox = document.getElementById('gridCheckbox');

        let items = []; // {id, type, x, y, el}
        let tilingSprite = null; // {id, el, width, height}
        let typeCounters = {}; // Track count of each type
        // assetsPool stores a single dataURL per image type to avoid duplicating base64 strings
        // format: { [type]: dataURL }
        let assetsPool = {};
        let hoveredItem = null; // Track currently hovered item for deletion
        let guideLineAngle = 60; // Current guide line angle in degrees
        let gridSize = 80; // Current grid size in pixels
        let gridElement = null; // Grid overlay element
        // Undo stack
        let undoStack = [];
        const UNDO_LIMIT = 20;
        let isPerformingUndo = false; // Prevent recording actions while undoing

        function pushAction(action) {
            if (isPerformingUndo) return;
            undoStack.push(action);
            if (undoStack.length > UNDO_LIMIT) undoStack.shift();
        }

        // Helper to recreate an item from saved data (used for undo delete)
        function recreateItemFromData(data) {
            const img = document.createElement('img');
            // Prefer assetsPool entry for the type, fall back to embedded src if present
            img.src = assetsPool[data.type] || data.src;
            img.className = 'item';
            img.style.left = data.x + 'px';
            img.style.top = data.y + 'px';
            if (data.flipped) img.style.transform = 'scaleX(-1)';
            editor.appendChild(img);

            if (!typeCounters[data.type]) typeCounters[data.type] = 0;
            typeCounters[data.type] = Math.max(typeCounters[data.type], data.id);

            const newItem = { id: data.id, type: data.type, x: data.x, y: data.y, el: img, flipped: !!data.flipped, background: !!data.background };
            if (newItem.background) {
                img.classList.add('background');
                img.style.zIndex = '1';
            }

            items.push(newItem);
            makeDraggable(img, newItem);
            updateAllZIndexes();
            updateItemHorizon(newItem);
            return newItem;
        }

        function undo() {
            if (undoStack.length === 0) return;
            const action = undoStack.pop();
            isPerformingUndo = true;
            try {
                if (action.type === 'add') {
                    const idx = items.findIndex(i => i.id === action.item.id && i.type === action.item.type);
                    if (idx !== -1) {
                        const it = items[idx];
                        removeGuideLines(it);
                        it.el.remove();
                        items.splice(idx, 1);
                    }
                    updateAllZIndexes();
                } else if (action.type === 'delete') {
                    recreateItemFromData(action.item);
                } else if (action.type === 'move') {
                    const it = items.find(i => i.id === action.itemId && i.type === action.itemType);
                    if (it) {
                        it.x = action.from.x;
                        it.y = action.from.y;
                        it.el.style.left = it.x + 'px';
                        it.el.style.top = it.y + 'px';
                        updateAllZIndexes();
                        positionGuideLines(it, {
                            left: document.getElementById(`guide-left-${it.id}-${it.type}`),
                            right: document.getElementById(`guide-right-${it.id}-${it.type}`),
                            horiz: document.getElementById(`guide-h-${it.id}-${it.type}`)
                        });
                    }
                } else if (action.type === 'flip') {
                    const it = items.find(i => i.id === action.itemId && i.type === action.itemType);
                    if (it) {
                        it.flipped = action.previousFlipped;
                        it.el.style.transform = it.flipped ? 'scaleX(-1)' : 'scaleX(1)';
                    }
                } else if (action.type === 'background') {
                    const it = items.find(i => i.id === action.itemId && i.type === action.itemType);
                    if (it) {
                        it.background = action.previousBackground;
                        if (it.background) {
                            it.el.classList.add('background');
                            it.el.style.zIndex = '1';
                        } else {
                            it.el.classList.remove('background');
                            updateAllZIndexes();
                        }
                    }
                } else if (action.type === 'tiling-add') {
                    if (tilingSprite) {
                        tilingSprite.el.remove();
                        tilingSprite = null;
                    }
                } else if (action.type === 'tiling-remove') {
                    const data = action.data;
                    // Prefer assets from action snapshot, then global pool, then embedded originalSrc
                    const src = (action.assets && action.assets[data.type]) || assetsPool[data.type] || data.originalSrc;
                    const tilingDiv = document.createElement('div');
                    tilingDiv.style.position = 'absolute';
                    tilingDiv.style.left = '0px';
                    tilingDiv.style.top = '0px';
                    tilingDiv.style.width = '100%';
                    tilingDiv.style.height = '100%';
                    tilingDiv.style.backgroundImage = `url(${src})`;
                    tilingDiv.style.backgroundRepeat = 'repeat';
                    if (data.width) tilingDiv.style.backgroundSize = `${data.width}px`;
                    tilingDiv.style.pointerEvents = 'none';
                    tilingDiv.style.zIndex = '1';
                    editor.appendChild(tilingDiv);
                    tilingSprite = { id: data.id, type: data.type, el: tilingDiv, width: data.width, height: data.height, originalSrc: src };
                } else if (action.type === 'clear-scene') {
                    // Restore assets snapshot if present so recreated items can reference them
                    if (action.assets && typeof action.assets === 'object') {
                        assetsPool = Object.assign({}, action.assets);
                    }
                    // recreate items
                    if (action.items && Array.isArray(action.items)) {
                        action.items.forEach(d => recreateItemFromData(d));
                    }
                    // recreate tiling if present
                    if (action.tiling) {
                        const data = action.tiling;
                        const src = (action.assets && action.assets[data.type]) || assetsPool[data.type] || data.originalSrc;
                        const tilingDiv = document.createElement('div');
                        tilingDiv.style.position = 'absolute';
                        tilingDiv.style.left = '0px';
                        tilingDiv.style.top = '0px';
                        tilingDiv.style.width = '100%';
                        tilingDiv.style.height = '100%';
                        tilingDiv.style.backgroundImage = `url(${src})`;
                        tilingDiv.style.backgroundRepeat = 'repeat';
                        if (data.width) tilingDiv.style.backgroundSize = `${data.width}px`;
                        tilingDiv.style.pointerEvents = 'none';
                        tilingDiv.style.zIndex = '1';
                        editor.appendChild(tilingDiv);
                        tilingSprite = { id: data.id, type: data.type, el: tilingDiv, width: data.width, height: data.height, originalSrc: src };
                    }
                }
            } finally {
                isPerformingUndo = false;
            }
        }

        // Panning variables
        let isPanning = false;
        let isSpacePressed = false;
        let panStartX = 0;
        let panStartY = 0;
        let editorOffsetX = 0;
        let editorOffsetY = 0;

        // Zoom variables
        let zoomLevel = 1;
        const minZoom = 0.1;
        const maxZoom = 3;
        const zoomStep = 0.1;

        // Function to update z-index for all items based on their bottom position
        function updateAllZIndexes() {
            // Calculate z-index based on each item's isometric horizon Y
            const editorRect = editor.getBoundingClientRect();
            items.forEach(item => {
                const el = item.el;
                // If item is pinned as background, keep it at z-index 1
                if (item.background) {
                    el.style.zIndex = '1';
                    return;
                }
                // item top-left in editor coordinates (style.left/top are editor coords)
                const itemX = parseFloat(el.style.left) || 0;
                const itemY = parseFloat(el.style.top) || 0;
                const itemHeight = el.offsetHeight;

                // Compute horizon distance from bottom of the image (px)
                const originFromBottom = calculateIsometricHorizon(el);

                // Editor Y coordinate of the horizon
                const horizonY = (itemY + itemHeight) - originFromBottom;

                // Use horizonY relative to editor's top for stacking
                const relativeHorizon = horizonY - editorRect.top;

                // Assign zIndex based on the horizon position (floor to integer)
                el.style.zIndex = Math.floor(relativeHorizon).toString();
            });
        }

        // Function to create guide lines for an item
        function createGuideLines(item) {
            // Create left guide line
            const leftLine = document.createElement('div');
            leftLine.className = 'guide-line';
            leftLine.id = `guide-left-${item.id}-${item.type}`;
            leftLine.style.transform = `rotate(${-guideLineAngle}deg)`;
            editor.appendChild(leftLine);

            // Create right guide line
            const rightLine = document.createElement('div');
            rightLine.className = 'guide-line';
            rightLine.id = `guide-right-${item.id}-${item.type}`;
            rightLine.style.transform = `rotate(${guideLineAngle}deg)`;
            editor.appendChild(rightLine);

            // Create horizontal guide line at the horizon y
            const horizLine = document.createElement('div');
            horizLine.className = 'h-guide-line';
            horizLine.id = `guide-h-${item.id}-${item.type}`;
            editor.appendChild(horizLine);

            return { left: leftLine, right: rightLine, horiz: horizLine };
        }

        // Function to position guide lines at the center bottom of an item
        function positionGuideLines(item, guideLines) {
            // Get item position and dimensions in editor coordinates
            const itemX = parseFloat(item.el.style.left) || 0;
            const itemY = parseFloat(item.el.style.top) || 0;
            const itemWidth = item.el.offsetWidth;
            const itemHeight = item.el.offsetHeight;

            // Calculate center bottom position in editor coordinates
            const centerX = itemX + itemWidth / 2;
            const bottomY = itemY + itemHeight;

            // Calculate line height (guide lines are in editor coordinate system)
            // Make lines long enough to be visible across the entire editor area
            const lineHeight = Math.max(2000, window.innerWidth + window.innerHeight);

            // Position both lines at the center bottom of the item
            // Guide lines inherit the editor's transform, so use editor coordinates directly
            [guideLines.left, guideLines.right].forEach(line => {
                line.style.left = (centerX - 1) + 'px'; // -1 to center the 2px wide line
                line.style.top = (bottomY - lineHeight / 2) + 'px'; // Center the line at the intersection point
                line.style.height = lineHeight + 'px';
            });

            // Position horizontal guide line at the computed horizon Y (editor coords)
            const horizLine = document.getElementById(`guide-h-${item.id}-${item.type}`);
            if (horizLine) {
                // compute horizon relative to the item's top-left editor position
                // item.el.style.top is item's top in editor coords; horizon is measured from image bottom
                const imgHeight = item.el.naturalHeight || item.el.offsetHeight;
                const originFromBottom = calculateIsometricHorizon(item.el);
                const horizonY = (itemY + itemHeight) - originFromBottom; // editor Y coordinate for the horizon

                horizLine.style.left = '0px';
                horizLine.style.width = '100%';
                horizLine.style.top = (horizonY - 1) + 'px'; // -1 to center 2px height
                horizLine.style.display = 'block';
            }
        }

        // Function to hide guide lines from all items
        function hideAllGuideLines() {
            items.forEach(otherItem => {
                hideGuideLines(otherItem);
            });
        }

        // Function to show guide lines for an item
        function showGuideLines(item) {
            console.log('showGuideLines called for:', item.id, item.type);

            // First, hide guide lines from all other items to ensure only one item shows guides
            hideAllGuideLines();

            // Check if guide lines already exist
            let leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            let rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            if (!leftLine || !rightLine) {
                console.log('Creating new guide lines');
                const guideLines = createGuideLines(item);
                leftLine = guideLines.left;
                rightLine = guideLines.right;
            } else {
                console.log('Using existing guide lines');
            }

            // Position and show the lines
            const horizLine = document.getElementById(`guide-h-${item.id}-${item.type}`);
            positionGuideLines(item, { left: leftLine, right: rightLine, horiz: horizLine });
            leftLine.style.display = 'block';
            rightLine.style.display = 'block';
            if (horizLine) horizLine.style.display = 'block';
            console.log('Guide lines should now be visible');
        }

        // Function to hide guide lines for an item
        function hideGuideLines(item) {
            const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            const horizLine = document.getElementById(`guide-h-${item.id}-${item.type}`);
            if (leftLine) leftLine.style.display = 'none';
            if (rightLine) rightLine.style.display = 'none';
            if (horizLine) horizLine.style.display = 'none';
        }

        // Function to remove guide lines for an item (when item is deleted)
        function removeGuideLines(item) {
            const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            const horizLine = document.getElementById(`guide-h-${item.id}-${item.type}`);
            if (leftLine) leftLine.remove();
            if (rightLine) rightLine.remove();
            if (horizLine) horizLine.remove();
        }

        // Function to delete an item
        function deleteItem(item) {
            console.log('Deleting item:', item.id, item.type);

            // Remove guide lines
            removeGuideLines(item);

            // Remove the element from DOM
            item.el.remove();

            // Remove from items array
            const index = items.findIndex(i => i.id === item.id && i.type === item.type);
            if (index !== -1) {
                items.splice(index, 1);
            }

            // Push delete action with item data so it can be restored
            try {
                // Save only type reference instead of full src when possible
                const itemDataForUndo = { id: item.id, type: item.type, x: item.x, y: item.y, flipped: item.flipped, background: item.background };
                // If no asset in pool for this type, include src to ensure undo works
                if (!assetsPool[item.type]) itemDataForUndo.src = item.el.src;
                pushAction({ type: 'delete', item: itemDataForUndo });
            } catch (err) {
                console.warn('Failed to push delete action', err);
            }

            // Clear hovered item if it was the deleted one
            if (hoveredItem === item) {
                hoveredItem = null;
            }

            // Update z-indexes after deletion
            updateAllZIndexes();

            console.log('Item deleted successfully');
        }

        // Function to clear the current scene
        function clearScene() {
            // Snapshot current scene for undo
            try {
                const itemsSnapshot = items.map(it => ({ id: it.id, type: it.type, x: it.x, y: it.y, src: it.el.src, flipped: it.flipped, background: it.background }));
                const tilingSnapshot = tilingSprite ? { id: tilingSprite.id, type: tilingSprite.type, width: tilingSprite.width, height: tilingSprite.height, originalSrc: tilingSprite.originalSrc } : null;
                // Snapshot assets that are currently used so undo can restore them without embedding multiple copies
                const assetsSnapshot = Object.assign({}, assetsPool);
                pushAction({ type: 'clear-scene', items: itemsSnapshot, tiling: tilingSnapshot, assets: assetsSnapshot });
            } catch (err) {
                console.warn('Failed to push clear-scene action', err);
            }

            // Remove all items and their guide lines
            items.forEach(item => {
                removeGuideLines(item);
                item.el.remove();
            });
            items = [];

            // Remove tiling sprite if exists
            if (tilingSprite) {
                tilingSprite.el.remove();
                tilingSprite = null;
            }

            // Remove grid if exists
            if (gridElement) {
                gridElement.remove();
                gridElement = null;
                gridCheckbox.checked = false;
            }

            // Reset type counters
            typeCounters = {};
        }

        fileInput.addEventListener('change', (e) => {

            for (const file of e.target.files) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataURL = event.target.result;
                    const img = document.createElement('img');
                    img.src = dataURL;
                    img.className = 'item';

                    editor.appendChild(img);

                    const type = file.name.split('.')[0];

                    // Register asset in pool if not present
                    if (!assetsPool[type]) {
                        assetsPool[type] = dataURL;
                    }

                    // Initialize counter for this type if it doesn't exist
                    if (!typeCounters[type]) {
                        typeCounters[type] = 0;
                    }

                    // Increment counter and use it as id
                    typeCounters[type]++;
                    const id = typeCounters[type];

                    const x = (-editorOffsetX + (window.innerWidth / 2) - img.naturalWidth / 2) / zoomLevel;
                    const y = (-editorOffsetY + (window.innerHeight / 2) - img.naturalHeight) / zoomLevel;
                    const item = { id, type, x, y, el: img, flipped: false };

                    img.style.left = x + 'px';
                    img.style.top = y + 'px';

                    items.push(item);

                    // Record add action for undo. Save only a type reference; include src only if pool missing
                    const addData = { id: item.id, type: item.type, x: item.x, y: item.y, flipped: false, background: false };
                    pushAction({ type: 'add', item: addData });

                    makeDraggable(img, item);

                    // Update z-indexes and horizon after adding new item once loaded
                    img.onload = () => {
                        updateAllZIndexes();
                        updateItemHorizon(item);
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Tiling sprite functionality
        tilingBtn.addEventListener('click', () => {
            tilingInput.click();
        });

        // Load scene functionality
        loadSceneBtn.addEventListener('click', () => {
            loadSceneInput.click();
        });

        // Panning and zoom functionality
        function updateEditorPosition() {
            editor.style.transformOrigin = '0 0';

            // Limit left and top edges
            if (editorOffsetX > 0) {
                editorOffsetX = 0;
            }
            if (editorOffsetY > 0) {
                editorOffsetY = 0;
            }

            // Calculate editor and viewport dimensions
            const editorWidth = 10 * window.innerWidth; // 1000vw
            const editorHeight = 10 * window.innerHeight; // 1000vh
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight - 40; // minus toolbar height

            // Calculate scaled editor dimensions
            const scaledEditorWidth = editorWidth * zoomLevel;
            const scaledEditorHeight = editorHeight * zoomLevel;

            // Limit right and bottom edges
            const minOffsetX = -(scaledEditorWidth - viewportWidth);
            const minOffsetY = -(scaledEditorHeight - viewportHeight);

            if (editorOffsetX < minOffsetX) {
                editorOffsetX = minOffsetX;
            }
            if (editorOffsetY < minOffsetY) {
                editorOffsetY = minOffsetY;
            }

            editor.style.transform = `translate(${editorOffsetX}px, ${editorOffsetY}px) scale(${zoomLevel})`;

        }

        // Function to flip an item horizontally
        function flipItem(item) {
            console.log('Flipping item:', item.id, item.type);

            // Toggle flipped state
            item.flipped = !item.flipped;

            // Apply CSS transform
            if (item.flipped) {
                item.el.style.transform = 'scaleX(-1)';
            } else {
                item.el.style.transform = 'scaleX(1)';
            }

            console.log('Item flipped state:', item.flipped);
        }

        // Keyboard event listeners for spacebar, delete, and flip
        document.addEventListener('keydown', (e) => {
            // Handle Ctrl+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
                return;
            }
            if (e.key === ' ' && !isSpacePressed) {
                e.preventDefault();
                isSpacePressed = true;
                editorContainer.classList.add('panning');
            } else if (e.key === 'Delete' && hoveredItem) {
                e.preventDefault();
                deleteItem(hoveredItem);
            } else if (e.key.toLowerCase() === 't' || e.key.toLowerCase() === 'r') {
                if (hoveredItem) {
                    e.preventDefault();
                    // record previous flipped state
                    const prev = hoveredItem.flipped;
                    flipItem(hoveredItem);
                    pushAction({ type: 'flip', itemId: hoveredItem.id, itemType: hoveredItem.type, previousFlipped: prev });
                }
            } else if (e.key.toLowerCase() === 'b') {
                // Toggle background pin on hovered item
                if (hoveredItem) {
                    e.preventDefault();
                    const prevBg = !!hoveredItem.background;
                    hoveredItem.background = !hoveredItem.background;
                    if (hoveredItem.background) {
                        hoveredItem.el.classList.add('background');
                        hoveredItem.el.style.zIndex = '1';
                    } else {
                        hoveredItem.el.classList.remove('background');
                        // Recalculate z-indexes for this item
                        updateAllZIndexes();
                    }
                    pushAction({ type: 'background', itemId: hoveredItem.id, itemType: hoveredItem.type, previousBackground: prevBg });
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                isSpacePressed = false;
                isPanning = false;
                editorContainer.classList.remove('panning');
            }
        });

        // Mouse event listeners for panning
        function buildExportData(includeAssets) {
            console.log('Export started. Items count:', items.length);
            console.log('Tiling sprite exists:', !!tilingSprite);

            const itemsData = items.map(i => {
                const itemX = parseFloat(i.el.style.left) || 0;
                const itemY = parseFloat(i.el.style.top) || 0;
                const itemWidth = i.el.offsetWidth;
                const itemHeight = i.el.offsetHeight;
                const centerX = itemX + itemWidth / 2;
                const bottomY = itemY + itemHeight;
                const itemData = { id: i.id, type: i.type, x: centerX, y: bottomY };
                if (i.flipped) {
                    itemData.scaleX = -1;
                }
                if (i.background) {
                    itemData.background = true;
                }
                return itemData;
            });

            console.log('Exported items data:', itemsData);

            const exportData = {
                items: itemsData,
                tilingSprite: tilingSprite ? {
                    id: tilingSprite.id,
                    type: tilingSprite.type,
                    width: tilingSprite.width,
                    height: tilingSprite.height
                } : null,
                gridAngle: guideLineAngle,
                gridSize: gridSize,
                gridVisible: gridCheckbox.checked,
                // Save camera/view state
                camera: {
                    zoomLevel: zoomLevel,
                    offsetX: editorOffsetX,
                    offsetY: editorOffsetY
                }
            };

            if (includeAssets) {
                // Export single assets pool to avoid duplicate base64 per item
                exportData.assets = assetsPool;
            }

            return exportData;
        }

        function triggerExport(exportObj, filename) {
            const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);

            console.log('Export completed successfully');
        }

        exportWithAssetsBtn.addEventListener('click', () => {
            const data = buildExportData(true);
            triggerExport(data, 'isometric_scene_with_assets.json');
        });

        exportWithoutAssetsBtn.addEventListener('click', () => {
            const data = buildExportData(false);
            triggerExport(data, 'isometric_scene.json');
        });

        // Zoom functionality with mouse wheel
        function handleZoom(e, mouseX, mouseY) {
            e.preventDefault();

            const zoomDelta = e.deltaY > 0 ? -zoomStep : zoomStep;
            const oldZoom = zoomLevel;
            const newZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel + zoomDelta));

            if (newZoom === oldZoom) return; // No change needed

            // Get mouse position relative to editor container
            const containerRect = editorContainer.getBoundingClientRect();
            const mouseX_rel = mouseX - containerRect.left;
            const mouseY_rel = mouseY - containerRect.top;

            // The key insight: find what point in the original editor coordinate system is under the mouse
            // Then ensure that same point stays under the mouse after zoom
            const worldX = (mouseX_rel - editorOffsetX) / oldZoom;
            const worldY = (mouseY_rel - editorOffsetY) / oldZoom;

            // Update zoom
            zoomLevel = newZoom;

            // Adjust offset so the world point stays under the mouse
            editorOffsetX = mouseX_rel - worldX * newZoom;
            editorOffsetY = mouseY_rel - worldY * newZoom;

            updateEditorPosition();
        }

        // Mouse wheel event listener
        editorContainer.addEventListener('wheel', (e) => {
            handleZoom(e, e.clientX, e.clientY);
        });

        tilingInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];

                // Remove existing tiling sprite if any
                if (tilingSprite) {
                    // record previous tiling so it can be restored
                    try { pushAction({ type: 'tiling-remove', data: { id: tilingSprite.id, type: tilingSprite.type, width: tilingSprite.width, height: tilingSprite.height, originalSrc: tilingSprite.originalSrc } }); } catch (err) { console.warn(err); }
                    tilingSprite.el.remove();
                    tilingSprite = null;
                }

                // Create tiling data for the new sprite
                const type = file.name.split('.')[0];
                const tilingData = {
                    id: type + '_tiling',
                    type: type
                };

                // Reuse the loadTilingSprite function
                loadTilingSprite(file, tilingData);
            }
        });

        // Load scene input handler
        loadSceneInput.addEventListener('change', (e) => {
            if (e.target.files.length === 0) return;

            const files = Array.from(e.target.files);
            const jsonFile = files.find(file => file.name.toLowerCase().endsWith('.json'));
            const imageFiles = files.filter(file => file.type.startsWith('image/'));

            if (!jsonFile) {
                alert('Please select a JSON file along with the images.');
                // Clear the input value to allow reselection
                e.target.value = '';
                return;
            }

            // Clear current scene
            clearScene();

            // Read the JSON file
            const jsonReader = new FileReader();
            jsonReader.onload = (event) => {
                try {
                    const sceneData = JSON.parse(event.target.result);
                    loadScene(sceneData, imageFiles);
                    // Clear the input value after successful loading to allow loading another scene
                    e.target.value = '';
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                    // Clear the input value even on error to allow retry
                    e.target.value = '';
                }
            };
            jsonReader.readAsText(jsonFile);
        });

        // Function to load a scene from JSON data and image files
        function loadScene(sceneData, imageFiles) {
            // Create a map of image files by their base name (without extension)
            const imageMap = {};
            imageFiles.forEach(file => {
                const baseName = file.name.split('.')[0];
                imageMap[baseName] = file;
            });

            // Load grid settings if they exist in the scene data
            if (sceneData.gridAngle !== undefined) {
                updateAngle(sceneData.gridAngle);
            }
            if (sceneData.gridSize !== undefined) {
                updateGridSize(sceneData.gridSize);
            }
            if (sceneData.gridVisible !== undefined) {
                gridCheckbox.checked = sceneData.gridVisible;
                toggleGrid(); // Apply the grid visibility state
            }

            // Load camera/view state if it exists in the scene data
            if (sceneData.camera) {
                if (sceneData.camera.zoomLevel !== undefined) {
                    zoomLevel = sceneData.camera.zoomLevel;
                }
                if (sceneData.camera.offsetX !== undefined) {
                    editorOffsetX = sceneData.camera.offsetX;
                }
                if (sceneData.camera.offsetY !== undefined) {
                    editorOffsetY = sceneData.camera.offsetY;
                }
                // Apply the loaded camera state
                updateEditorPosition();
            }

            // If the scene includes an assets map, populate assetsPool
            if (sceneData.assets && typeof sceneData.assets === 'object') {
                Object.keys(sceneData.assets).forEach(k => {
                    if (!assetsPool[k]) assetsPool[k] = sceneData.assets[k];
                });
            }

            // Load tiling sprite if exists. Prefer assetsPool, otherwise look for uploaded image file
            if (sceneData.tilingSprite) {
                if (assetsPool[sceneData.tilingSprite.type]) {
                    // Create tiling from pool
                    const tilingDiv = document.createElement('div');
                    tilingDiv.style.position = 'absolute';
                    tilingDiv.style.left = '0px';
                    tilingDiv.style.top = '0px';
                    tilingDiv.style.width = '100%';
                    tilingDiv.style.height = '100%';
                    tilingDiv.style.backgroundImage = `url(${assetsPool[sceneData.tilingSprite.type]})`;
                    tilingDiv.style.backgroundRepeat = 'repeat';
                    if (sceneData.tilingSprite.width) tilingDiv.style.backgroundSize = `${sceneData.tilingSprite.width}px`;
                    tilingDiv.style.pointerEvents = 'none';
                    tilingDiv.style.zIndex = '1';
                    editor.appendChild(tilingDiv);
                    tilingSprite = { id: sceneData.tilingSprite.id, type: sceneData.tilingSprite.type, el: tilingDiv, width: sceneData.tilingSprite.width, height: sceneData.tilingSprite.height, originalSrc: assetsPool[sceneData.tilingSprite.type] };
                } else {
                    const tilingImageFile = imageFiles.find(file => file.name.split('.')[0] === sceneData.tilingSprite.type);
                    if (tilingImageFile) {
                        loadTilingSprite(tilingImageFile, sceneData.tilingSprite);
                    } else {
                        console.warn(`Tiling sprite image file not found for type: ${sceneData.tilingSprite.type}`);
                    }
                }
            }

            // Load items
            if (sceneData.items) {
                sceneData.items.forEach(itemData => {
                    // Prefer assetsPool for this type; if not available, try uploaded image files
                    const imageFile = imageMap[itemData.type];
                    if (assetsPool[itemData.type]) {
                        // Create item using assetsPool directly
                        loadItem(itemData, null);
                    } else if (imageFile) {
                        loadItem(itemData, imageFile);
                    } else {
                        console.warn(`Image file not found for item type: ${itemData.type}`);
                        // Still attempt to load if itemData contains embedded src (back-compat)
                        loadItem(itemData, null);
                    }
                });
            }
        }

        // Function to load a tiling sprite
        function loadTilingSprite(imageFile, tilingData) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    console.log('img.naturalWidth', img);

                    // Create a div with the tiled background using the image URL directly
                    const tilingDiv = document.createElement('div');
                    tilingDiv.style.position = 'absolute';
                    tilingDiv.style.left = '0px';
                    tilingDiv.style.top = '0px';
                    tilingDiv.style.width = '100%';
                    tilingDiv.style.height = '100%';
                    tilingDiv.style.backgroundImage = `url(${event.target.result})`;
                    tilingDiv.style.backgroundRepeat = 'repeat';
                    tilingDiv.style.backgroundSize = `${img.naturalWidth}px`;
                    tilingDiv.style.pointerEvents = 'none';
                    tilingDiv.style.zIndex = '1';

                    editor.appendChild(tilingDiv);

                    // Register asset in pool for the tiling type
                    if (!assetsPool[tilingData.type]) {
                        assetsPool[tilingData.type] = event.target.result;
                    }

                    tilingSprite = {
                        id: tilingData.id,
                        type: tilingData.type,
                        el: tilingDiv,
                        width: tilingData.width,
                        height: tilingData.height,
                        originalSrc: event.target.result
                    };
                    // Record tiling add for undo
                    try { pushAction({ type: 'tiling-add', data: { id: tilingSprite.id, type: tilingSprite.type, width: tilingSprite.width, height: tilingSprite.height, originalSrc: tilingSprite.originalSrc } }); } catch (err) { console.warn(err); }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(imageFile);
        }

        // Function to load an individual item
        function loadItem(itemData, imageFile) {
            const reader = new FileReader();
            // If an imageFile is provided, read it; otherwise use assetsPool or embedded src
            if (imageFile) {
                reader.onload = (event) => {
                    createItemFromSrc(itemData, event.target.result);
                };
                reader.readAsDataURL(imageFile);
            } else {
                // Use pool or embedded src
                const src = assetsPool[itemData.type] || itemData.src || '';
                createItemFromSrc(itemData, src);
            }
        }

        // Helper to create an item element given preloaded src
        function createItemFromSrc(itemData, src) {
            const img = document.createElement('img');
            img.src = src;
            img.className = 'item';

            img.onload = () => {
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;

                // Calculate left and top positions from center X and bottom Y
                const leftPos = itemData.x - (imgWidth / 2);
                const topPos = itemData.y - imgHeight;

                img.style.left = leftPos + 'px';
                img.style.top = topPos + 'px';

                editor.appendChild(img);

                // Update type counter to match the loaded item's ID
                if (!typeCounters[itemData.type]) {
                    typeCounters[itemData.type] = 0;
                }
                typeCounters[itemData.type] = Math.max(typeCounters[itemData.type], itemData.id);

                const item = {
                    id: itemData.id,
                    type: itemData.type,
                    x: leftPos,
                    y: topPos,
                    el: img,
                    flipped: itemData.scaleX === -1,
                    background: !!itemData.background
                };

                // Apply flip transform if item was flipped
                if (item.flipped) {
                    img.style.transform = 'scaleX(-1)';
                } else {
                    img.style.transform = 'scaleX(1)';
                }

                // Apply background class and z-index if item is marked as background
                if (item.background) {
                    img.classList.add('background');
                    img.style.zIndex = '1';
                }

                items.push(item);

                makeDraggable(img, item);

                // Update z-indexes after loading
                updateAllZIndexes();
                // Set item horizon pivot based on current grid angle
                updateItemHorizon(item);
            };
        }

        function makeDraggable(el, item) {
            let offsetX, offsetY, dragging = false;

            // Prevent default drag behavior on the image
            el.addEventListener('dragstart', (e) => e.preventDefault());
            el.addEventListener('contextmenu', (e) => e.preventDefault());

            // Add hover event listeners for guide lines
            el.addEventListener('mouseenter', () => {
                if (!dragging) {
                    console.log('Showing guide lines for item:', item.id, item.type);
                    hoveredItem = item; // Track hovered item for deletion
                    showGuideLines(item);
                }
            });

            el.addEventListener('mouseleave', () => {
                if (!dragging) {
                    console.log('Hiding guide lines for item:', item.id, item.type);
                    hoveredItem = null; // Clear hovered item
                    hideGuideLines(item);
                }
            });

            el.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Prevent default behavior
                dragging = true;
                const isDuplicating = e.altKey; // Check if Alt key is held

                // Calculate offset using the same coordinate system as mousemove
                const containerRect = editorContainer.getBoundingClientRect();
                const mouseXInContainer = e.clientX - containerRect.left;
                const mouseYInContainer = e.clientY - containerRect.top;

                // Convert to editor coordinates (accounting for pan and zoom)
                const editorMouseX = (mouseXInContainer - editorOffsetX) / zoomLevel;
                const editorMouseY = (mouseYInContainer - editorOffsetY) / zoomLevel;

                // Get current item position
                const currentX = parseFloat(el.style.left) || 0;
                const currentY = parseFloat(el.style.top) || 0;

                // Calculate offset between mouse and item position
                offsetX = editorMouseX - currentX;
                offsetY = editorMouseY - currentY;

                let currentEl = el;
                let currentItem = item;

                // store drag start position to later create move action
                if (currentItem) {
                    currentItem._dragFrom = { x: currentItem.x, y: currentItem.y };
                }

                if (isDuplicating) {
                    // Create a duplicate
                    const newImg = el.cloneNode(true);
                    newImg.style.left = el.style.left;
                    newImg.style.top = el.style.top;
                    newImg.style.opacity = '0.8';
                    // Ensure duplicates do not inherit the background/pinned state visually
                    newImg.classList.remove('background');
                    newImg.style.zIndex = '';
                    editor.appendChild(newImg);

                    // Create new item data with proper type-based id and preserve flip state
                    typeCounters[item.type]++;
                    const newId = typeCounters[item.type];
                    // Do not copy the `background` flag to the duplicate (duplicates should be regular items)
                    const duplicatedItem = { id: newId, type: item.type, x: item.x, y: item.y, el: newImg, flipped: item.flipped, background: false };

                    // Apply flip transform if original was flipped
                    if (item.flipped) {
                        newImg.style.transform = 'scaleX(-1)';
                    } else {
                        newImg.style.transform = 'scaleX(1)';
                    }

                    items.push(duplicatedItem);

                    // Record duplication as an add action for undo
                    try {
                        const addItem = { id: duplicatedItem.id, type: duplicatedItem.type, x: duplicatedItem.x, y: duplicatedItem.y, flipped: duplicatedItem.flipped, background: false };
                        if (!assetsPool[duplicatedItem.type]) addItem.src = newImg.src;
                        pushAction({ type: 'add', item: addItem });
                    } catch (err) {
                        console.warn('Failed to push duplication action', err);
                    }

                    // Make the duplicate draggable
                    // Preserve transform-origin for the duplicate so pivot stays consistent
                    newImg.style.transformOrigin = el.style.transformOrigin || '';
                    makeDraggable(newImg, duplicatedItem);

                    // Ensure horizon pivot is correct after duplication
                    updateItemHorizon(duplicatedItem);

                    // We'll be dragging the duplicate, not the original
                    currentEl = newImg;
                    currentItem = duplicatedItem;

                    // Update z-indexes after duplication
                    updateAllZIndexes();
                } else {
                    // Add visual feedback for normal drag
                    el.style.opacity = '0.8';
                }

                // Handle mouse move for this specific drag operation
                const handleMouseMove = (e) => {
                    if (!dragging) return;
                    e.preventDefault();

                    // Convert mouse position to editor coordinate system accounting for zoom
                    const containerRect = editorContainer.getBoundingClientRect();
                    const mouseXInContainer = e.clientX - containerRect.left;
                    const mouseYInContainer = e.clientY - containerRect.top;

                    // Convert to editor coordinates (accounting for pan and zoom)
                    const editorX = (mouseXInContainer - editorOffsetX) / zoomLevel;
                    const editorY = (mouseYInContainer - editorOffsetY) / zoomLevel;

                    // Apply the offset that was captured on mousedown
                    let x = editorX - offsetX;
                    let y = editorY - offsetY;

                    currentEl.style.left = x + 'px';
                    currentEl.style.top = y + 'px';
                    currentItem.x = x;
                    currentItem.y = y;

                    // Update guide lines position during drag
                    const leftLine = document.getElementById(`guide-left-${currentItem.id}-${currentItem.type}`);
                    const rightLine = document.getElementById(`guide-right-${currentItem.id}-${currentItem.type}`);
                    if (leftLine && rightLine && (leftLine.style.display === 'block' || rightLine.style.display === 'block')) {
                        positionGuideLines(currentItem, { left: leftLine, right: rightLine });
                    }

                    // Update z-indexes during drag to maintain proper layering
                    updateAllZIndexes();
                };

                // Handle mouse up for this specific drag operation
                const handleMouseUp = (e) => {
                    if (dragging) {
                        e.preventDefault();
                        dragging = false;

                        // Reset visual feedback
                        currentEl.style.opacity = '1';

                        // Final z-index update after drag completes
                        updateAllZIndexes();

                        // If the item moved, push a move action with from/to
                        if (currentItem) {
                            const idKey = currentItem.id;
                            const typeKey = currentItem.type;
                            // We don't have previous position saved here; capture from event if stored on item
                            if (currentItem._dragFrom) {
                                const from = { x: currentItem._dragFrom.x, y: currentItem._dragFrom.y };
                                const to = { x: currentItem.x, y: currentItem.y };
                                if (from.x !== to.x || from.y !== to.y) {
                                    pushAction({ type: 'move', itemId: idKey, itemType: typeKey, from, to });
                                }
                                delete currentItem._dragFrom;
                            }
                        }

                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                };

                // Add event listeners for this drag operation
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
        }

        // Function to create the grid element
        function createGrid() {
            if (gridElement) {
                gridElement.remove();
            }

            // Create SVG element for the grid
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.left = '0px';
            svg.style.top = '0px';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '10'; // Above tiling background (which is 1), below items
            svg.style.display = 'none';

            // Create the grid lines directly without patterns
            const gridSpacing = gridSize; // Use configurable grid size
            const viewportWidth = window.innerWidth * 10;
            const viewportHeight = window.innerHeight * 10;
            const maxDimension = Math.max(viewportWidth, viewportHeight);
            const lineExtent = maxDimension * 1.5; // Lines extend 1.5x the viewport size

            // Convert angle to radians for calculations
            // Guide lines are vertical lines rotated by the angle
            const leftAngleRad = (-guideLineAngle) * Math.PI / 180; // Left guide line angle
            const rightAngleRad = guideLineAngle * Math.PI / 180; // Right guide line angle

            // Calculate how many lines we need (reduced from previous implementation)
            const numLines = Math.ceil(maxDimension / gridSpacing);

            // Get the center of the viewport
            const centerX = viewportWidth / 2;
            const centerY = viewportHeight / 2;

            const lineWidth = 1;
            const lineColor = 'rgba(0, 0, 255, 0.35)';

            // Create left-angled lines (matching left guide line)
            for (let i = -numLines; i <= numLines; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                // For a rotated vertical line, the direction vector is (sin(angle), cos(angle))
                const dirX = Math.sin(leftAngleRad);
                const dirY = Math.cos(leftAngleRad);

                // Perpendicular direction for spacing lines apart
                const perpX = -dirY;
                const perpY = dirX;

                // Calculate offset for this line
                const offsetDistance = i * gridSpacing;
                const offsetX = offsetDistance * perpX;
                const offsetY = offsetDistance * perpY;

                // Line extends from center + offset in both directions along the direction
                const startX = centerX + offsetX - lineExtent * dirX;
                const startY = centerY + offsetY - lineExtent * dirY;
                const endX = centerX + offsetX + lineExtent * dirX;
                const endY = centerY + offsetY + lineExtent * dirY;

                line.setAttribute('x1', startX.toString());
                line.setAttribute('y1', startY.toString());
                line.setAttribute('x2', endX.toString());
                line.setAttribute('y2', endY.toString());
                line.setAttribute('stroke', lineColor);
                line.setAttribute('stroke-width', lineWidth);

                svg.appendChild(line);
            }

            // Create right-angled lines (matching right guide line)
            for (let i = -numLines; i <= numLines; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                // For a rotated vertical line, the direction vector is (sin(angle), cos(angle))
                const dirX = Math.sin(rightAngleRad);
                const dirY = Math.cos(rightAngleRad);

                // Perpendicular direction for spacing lines apart
                const perpX = -dirY;
                const perpY = dirX;

                // Calculate offset for this line
                const offsetDistance = i * gridSpacing;
                const offsetX = offsetDistance * perpX;
                const offsetY = offsetDistance * perpY;

                // Line extends from center + offset in both directions along the direction
                const startX = centerX + offsetX - lineExtent * dirX;
                const startY = centerY + offsetY - lineExtent * dirY;
                const endX = centerX + offsetX + lineExtent * dirX;
                const endY = centerY + offsetY + lineExtent * dirY;

                line.setAttribute('x1', startX.toString());
                line.setAttribute('y1', startY.toString());
                line.setAttribute('x2', endX.toString());
                line.setAttribute('y2', endY.toString());
                line.setAttribute('stroke', lineColor);
                line.setAttribute('stroke-width', lineWidth);

                svg.appendChild(line);
            }

            editor.appendChild(svg);
            gridElement = svg;
        }

        // Function to update grid angle
        function updateGridAngle() {
            // Recreate the grid with new angles
            if (gridCheckbox.checked && gridElement) {
                const wasVisible = gridElement.style.display !== 'none';
                createGrid();
                if (wasVisible) {
                    gridElement.style.display = 'block';
                }
            }
        }

        // Function to toggle grid visibility
        function toggleGrid() {
            if (!gridElement) {
                createGrid();
            }

            if (gridCheckbox.checked) {
                gridElement.style.display = 'block';
            } else {
                gridElement.style.display = 'none';
            }
        }

        // Function to update all existing guide lines with new angle
        function updateAllGuideLineAngles() {
            items.forEach(item => {
                const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
                const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

                if (leftLine) {
                    leftLine.style.transform = `rotate(${-guideLineAngle}deg)`;
                }
                if (rightLine) {
                    rightLine.style.transform = `rotate(${guideLineAngle}deg)`;
                }
            });
        }

        // Calculate isometric horizon (vertical distance from image bottom in px)
        // Based on image half-width and the current grid angle. If the
        // intersection point (where the angled guide line meets the top of
        // the image) lies outside the image bounds, the value is clamped.
        function calculateIsometricHorizon(img) {
            const W = img.naturalWidth || img.width || 0;
            const H = img.naturalHeight || img.height || 0;
            if (W === 0 || H === 0) return 0;

            const halfW = W / 2;
            const theta = guideLineAngle * Math.PI / 180; // angle in radians measured from vertical
            const tanTheta = Math.tan(theta);

            // Vertical rise from bottom to the intersection point where the
            // angled guide (starting at bottom center) reaches the image edge:
            // y = halfWidth / tan(theta)
            let y = halfW / tanTheta;

            // Clamp to image height
            if (!isFinite(y)) y = 0;
            if (y < 0) y = 0;
            if (y > H) y = H;

            return y; // px from bottom
        }

        // Update transform-origin for a single item element so its pivot is
        // placed at the isometric horizon (center horizontally, computed Y)
        function updateItemHorizon(item) {
            if (!item || !item.el) return;
            const img = item.el;
            // Only update when image has loaded its dimensions
            if (!img.complete || (img.naturalWidth === 0 && img.naturalHeight === 0)) return;

            const H = img.naturalHeight;
            const originFromBottom = calculateIsometricHorizon(img);
            const originY = Math.max(0, H - originFromBottom); // px from top
            const originX = (img.naturalWidth || img.width) / 2;

            img.style.transformOrigin = `${originX}px ${originY}px`;
        }

        function updateAllItemHorizons() {
            items.forEach(item => updateItemHorizon(item));
        }

        // Function to update angle and sync both inputs
        function updateAngle(newAngle) {
            guideLineAngle = Number(newAngle);
            angleSlider.value = guideLineAngle;
            angleInput.value = guideLineAngle;
            updateAllGuideLineAngles();
            updateGridAngle();
            // Update item horizons because they depend on grid angle
            updateAllItemHorizons();
        }

        // Function to update grid size and sync both inputs
        function updateGridSize(newSize) {
            gridSize = Number(newSize);
            gridSizeSlider.value = gridSize;
            gridSizeInput.value = gridSize;
            updateGridAngle(); // Recreate grid with new size
        }

        // Angle slider event listener
        angleSlider.addEventListener('input', (e) => {
            updateAngle(e.target.value);
        });

        // Angle text input event listener
        angleInput.addEventListener('input', (e) => {
            const value = Number(e.target.value);
            if (!isNaN(value) && value >= 45 && value <= 90) {
                updateAngle(value);
            }
        });

        // Handle invalid input on blur - reset to current valid value
        angleInput.addEventListener('blur', (e) => {
            const value = Number(e.target.value);
            if (isNaN(value) || value < 45 || value > 90) {
                angleInput.value = guideLineAngle;
            }
        });

        // Grid size slider event listener
        gridSizeSlider.addEventListener('input', (e) => {
            updateGridSize(e.target.value);
        });

        // Grid size text input event listener
        gridSizeInput.addEventListener('input', (e) => {
            const value = Number(e.target.value);
            if (!isNaN(value) && value >= 40 && value <= 120) {
                updateGridSize(value);
            }
        });

        // Handle invalid grid size input on blur - reset to current valid value
        gridSizeInput.addEventListener('blur', (e) => {
            const value = Number(e.target.value);
            if (isNaN(value) || value < 40 || value > 120) {
                gridSizeInput.value = gridSize;
            }
        });

        // Grid checkbox event listener
        gridCheckbox.addEventListener('change', toggleGrid);

    </script>

</body>
</html>