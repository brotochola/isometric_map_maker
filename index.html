<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Mini Image Editor</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        #toolbar {
            background: #ddd;
            padding: 5px;
        }

        #editor {
            position: relative;
            width: 1000vw;
            height: 1000vh;

            overflow: visible;
            background: #f0f0f0;
            border-top: 1px solid #aaa;
        }

        #editor-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 40px);
            overflow: hidden;
            background: #f0f0f0;
            border-top: 1px solid #aaa;
        }

        #editor-container.panning {
            cursor: grab;
        }

        #editor-container.panning:active {
            cursor: grabbing;
        }

        .item {
            border: 1px solid transparent;
            box-sizing: content-box;
            position: absolute;
            cursor: move;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            pointer-events: auto;
        }

        .guide-line {
            position: absolute;
            width: 2px;
            background-color: rgba(0, 0, 255, 0.5);
            opacity: 0.8;
            pointer-events: none;
            z-index: 9999;
            transform-origin: center center;
            display: none;

        }


        .item:hover {
            border: 1px solid rgba(0, 0, 255, 0.5);
        }
    </style>
</head>
<body>

    <div id="toolbar">
        <input type="file" id="fileInput" multiple accept="image/*">
        <input type="file" id="tilingInput" accept="image/*" style="display: none;">
        <input type="file" id="loadSceneInput" multiple accept=".json,image/*" style="display: none;">
        <button id="tilingBtn">Add Tiling Background</button>
        <button id="loadSceneBtn">Load Scene</button>
        <button id="exportBtn">Export JSON</button>
        <label for="angleSlider">Grid Angle:</label>
        <input type="range" id="angleSlider" min="45" max="90" value="60" step="0.1">
        <input type="number" id="angleInput" min="45" max="90" value="60" step="0.1" style="width: 60px;">
        <span>Â°</span>
        <label for="gridSizeSlider">Grid Size:</label>
        <input type="range" id="gridSizeSlider" min="10" max="120" value="80" step="1">
        <input type="number" id="gridSizeInput" min="10" max="120" value="80" step="1" style="width: 60px;">
        <span>px</span>
        <label for="gridCheckbox">
            <input type="checkbox" id="gridCheckbox"> Show Grid
        </label>
    </div>

    <div id="editor-container">
        <div id="editor"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const editorContainer = document.getElementById('editor-container');
        const fileInput = document.getElementById('fileInput');
        const tilingInput = document.getElementById('tilingInput');
        const tilingBtn = document.getElementById('tilingBtn');
        const loadSceneInput = document.getElementById('loadSceneInput');
        const loadSceneBtn = document.getElementById('loadSceneBtn');
        const exportBtn = document.getElementById('exportBtn');
        const angleSlider = document.getElementById('angleSlider');
        const angleInput = document.getElementById('angleInput');
        const gridSizeSlider = document.getElementById('gridSizeSlider');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridCheckbox = document.getElementById('gridCheckbox');

        let items = []; // {id, type, x, y, el}
        let tilingSprite = null; // {id, el, width, height}
        let typeCounters = {}; // Track count of each type
        let hoveredItem = null; // Track currently hovered item for deletion
        let guideLineAngle = 60; // Current guide line angle in degrees
        let gridSize = 80; // Current grid size in pixels
        let gridElement = null; // Grid overlay element

        // Panning variables
        let isPanning = false;
        let isSpacePressed = false;
        let panStartX = 0;
        let panStartY = 0;
        let editorOffsetX = 0;
        let editorOffsetY = 0;

        // Zoom variables
        let zoomLevel = 1;
        const minZoom = 0.1;
        const maxZoom = 3;
        const zoomStep = 0.1;

        // Function to update z-index for all items based on their bottom position
        function updateAllZIndexes() {
            items.forEach(item => {
                const rect = item.el.getBoundingClientRect();
                const editorRect = editor.getBoundingClientRect();
                const relativeBottom = rect.bottom - editorRect.top;
                item.el.style.zIndex = Math.floor(relativeBottom).toString();
            });
        }

        // Function to create guide lines for an item
        function createGuideLines(item) {
            // Create left guide line
            const leftLine = document.createElement('div');
            leftLine.className = 'guide-line';
            leftLine.id = `guide-left-${item.id}-${item.type}`;
            leftLine.style.transform = `rotate(${-guideLineAngle}deg)`;
            editor.appendChild(leftLine);

            // Create right guide line
            const rightLine = document.createElement('div');
            rightLine.className = 'guide-line';
            rightLine.id = `guide-right-${item.id}-${item.type}`;
            rightLine.style.transform = `rotate(${guideLineAngle}deg)`;
            editor.appendChild(rightLine);

            return { left: leftLine, right: rightLine };
        }

        // Function to position guide lines at the center bottom of an item
        function positionGuideLines(item, guideLines) {
            // Get item position and dimensions in editor coordinates
            const itemX = parseFloat(item.el.style.left) || 0;
            const itemY = parseFloat(item.el.style.top) || 0;
            const itemWidth = item.el.offsetWidth;
            const itemHeight = item.el.offsetHeight;

            // Calculate center bottom position in editor coordinates
            const centerX = itemX + itemWidth / 2;
            const bottomY = itemY + itemHeight;

            // Calculate line height (guide lines are in editor coordinate system)
            // Make lines long enough to be visible across the entire editor area
            const lineHeight = Math.max(2000, window.innerWidth + window.innerHeight);

            // Position both lines at the center bottom of the item
            // Guide lines inherit the editor's transform, so use editor coordinates directly
            [guideLines.left, guideLines.right].forEach(line => {
                line.style.left = (centerX - 1) + 'px'; // -1 to center the 2px wide line
                line.style.top = (bottomY - lineHeight / 2) + 'px'; // Center the line at the intersection point
                line.style.height = lineHeight + 'px';
            });
        }

        // Function to show guide lines for an item
        function showGuideLines(item) {
            console.log('showGuideLines called for:', item.id, item.type);
            // Check if guide lines already exist
            let leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            let rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            if (!leftLine || !rightLine) {
                console.log('Creating new guide lines');
                const guideLines = createGuideLines(item);
                leftLine = guideLines.left;
                rightLine = guideLines.right;
            } else {
                console.log('Using existing guide lines');
            }

            // Position and show the lines
            positionGuideLines(item, { left: leftLine, right: rightLine });
            leftLine.style.display = 'block';
            rightLine.style.display = 'block';
            console.log('Guide lines should now be visible');
        }

        // Function to hide guide lines for an item
        function hideGuideLines(item) {
            const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            if (leftLine) leftLine.style.display = 'none';
            if (rightLine) rightLine.style.display = 'none';
        }

        // Function to remove guide lines for an item (when item is deleted)
        function removeGuideLines(item) {
            const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
            const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

            if (leftLine) leftLine.remove();
            if (rightLine) rightLine.remove();
        }

        // Function to delete an item
        function deleteItem(item) {
            console.log('Deleting item:', item.id, item.type);

            // Remove guide lines
            removeGuideLines(item);

            // Remove the element from DOM
            item.el.remove();

            // Remove from items array
            const index = items.findIndex(i => i.id === item.id && i.type === item.type);
            if (index !== -1) {
                items.splice(index, 1);
            }

            // Clear hovered item if it was the deleted one
            if (hoveredItem === item) {
                hoveredItem = null;
            }

            // Update z-indexes after deletion
            updateAllZIndexes();

            console.log('Item deleted successfully');
        }

        // Function to clear the current scene
        function clearScene() {
            // Remove all items and their guide lines
            items.forEach(item => {
                removeGuideLines(item);
                item.el.remove();
            });
            items = [];

            // Remove tiling sprite if exists
            if (tilingSprite) {
                tilingSprite.el.remove();
                tilingSprite = null;
            }

            // Remove grid if exists
            if (gridElement) {
                gridElement.remove();
                gridElement = null;
                gridCheckbox.checked = false;
            }

            // Reset type counters
            typeCounters = {};
        }

        fileInput.addEventListener('change', (e) => {

            for (const file of e.target.files) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = document.createElement('img');
                    img.src = event.target.result;
                    img.className = 'item';

                    editor.appendChild(img);

                    const type = file.name.split('.')[0];

                    // Initialize counter for this type if it doesn't exist
                    if (!typeCounters[type]) {
                        typeCounters[type] = 0;
                    }

                    // Increment counter and use it as id
                    typeCounters[type]++;
                    const id = typeCounters[type];

                    const x = (-editorOffsetX + (window.innerWidth / 2) - img.naturalWidth / 2) / zoomLevel;
                    const y = (-editorOffsetY + (window.innerHeight / 2) - img.naturalHeight) / zoomLevel;
                    const item = { id, type, x, y, el: img, flipped: false };

                    img.style.left = x + 'px';
                    img.style.top = y + 'px';

                    items.push(item);

                    makeDraggable(img, item);

                    // Update z-indexes after adding new item
                    img.onload = () => {
                        updateAllZIndexes();
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Tiling sprite functionality
        tilingBtn.addEventListener('click', () => {
            tilingInput.click();
        });

        // Load scene functionality
        loadSceneBtn.addEventListener('click', () => {
            loadSceneInput.click();
        });

        // Panning and zoom functionality
        function updateEditorPosition() {
            editor.style.transformOrigin = '0 0';

            // Limit left and top edges
            if (editorOffsetX > 0) {
                editorOffsetX = 0;
            }
            if (editorOffsetY > 0) {
                editorOffsetY = 0;
            }

            // Calculate editor and viewport dimensions
            const editorWidth = 10 * window.innerWidth; // 1000vw
            const editorHeight = 10 * window.innerHeight; // 1000vh
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight - 40; // minus toolbar height

            // Calculate scaled editor dimensions
            const scaledEditorWidth = editorWidth * zoomLevel;
            const scaledEditorHeight = editorHeight * zoomLevel;

            // Limit right and bottom edges
            const minOffsetX = -(scaledEditorWidth - viewportWidth);
            const minOffsetY = -(scaledEditorHeight - viewportHeight);

            if (editorOffsetX < minOffsetX) {
                editorOffsetX = minOffsetX;
            }
            if (editorOffsetY < minOffsetY) {
                editorOffsetY = minOffsetY;
            }

            editor.style.transform = `translate(${editorOffsetX}px, ${editorOffsetY}px) scale(${zoomLevel})`;

        }

        // Function to flip an item horizontally
        function flipItem(item) {
            console.log('Flipping item:', item.id, item.type);

            // Toggle flipped state
            item.flipped = !item.flipped;

            // Apply CSS transform
            if (item.flipped) {
                item.el.style.transform = 'scaleX(-1)';
            } else {
                item.el.style.transform = 'scaleX(1)';
            }

            console.log('Item flipped state:', item.flipped);
        }

        // Keyboard event listeners for spacebar, delete, and flip
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' && !isSpacePressed) {
                e.preventDefault();
                isSpacePressed = true;
                editorContainer.classList.add('panning');
            } else if (e.key === 'Delete' && hoveredItem) {
                e.preventDefault();
                deleteItem(hoveredItem);
            } else if (e.key.toLowerCase() === 't' || e.key.toLowerCase() === 'r') {
                if (hoveredItem) {
                    e.preventDefault();
                    flipItem(hoveredItem);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                isSpacePressed = false;
                isPanning = false;
                editorContainer.classList.remove('panning');
            }
        });

        // Mouse event listeners for panning
        editorContainer.addEventListener('mousedown', (e) => {
            if (isSpacePressed) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isPanning && isSpacePressed) {
                e.preventDefault();
                const deltaX = e.clientX - panStartX;
                const deltaY = e.clientY - panStartY;

                editorOffsetX += deltaX;
                editorOffsetY += deltaY;




                updateEditorPosition();

                panStartX = e.clientX;
                panStartY = e.clientY;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isPanning) {
                e.preventDefault();
                isPanning = false;
            }
        });

        // Zoom functionality with mouse wheel
        function handleZoom(e, mouseX, mouseY) {
            e.preventDefault();

            const zoomDelta = e.deltaY > 0 ? -zoomStep : zoomStep;
            const oldZoom = zoomLevel;
            const newZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel + zoomDelta));

            if (newZoom === oldZoom) return; // No change needed

            // Get mouse position relative to editor container
            const containerRect = editorContainer.getBoundingClientRect();
            const mouseX_rel = mouseX - containerRect.left;
            const mouseY_rel = mouseY - containerRect.top;

            // The key insight: find what point in the original editor coordinate system is under the mouse
            // Then ensure that same point stays under the mouse after zoom
            const worldX = (mouseX_rel - editorOffsetX) / oldZoom;
            const worldY = (mouseY_rel - editorOffsetY) / oldZoom;

            // Update zoom
            zoomLevel = newZoom;

            // Adjust offset so the world point stays under the mouse
            editorOffsetX = mouseX_rel - worldX * newZoom;
            editorOffsetY = mouseY_rel - worldY * newZoom;

            updateEditorPosition();
        }

        // Mouse wheel event listener
        editorContainer.addEventListener('wheel', (e) => {
            handleZoom(e, e.clientX, e.clientY);
        });

        tilingInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];

                // Remove existing tiling sprite if any
                if (tilingSprite) {
                    tilingSprite.el.remove();
                }

                // Create tiling data for the new sprite
                const type = file.name.split('.')[0];
                const tilingData = {
                    id: type + '_tiling',
                    type: type
                };

                // Reuse the loadTilingSprite function
                loadTilingSprite(file, tilingData);
            }
        });

        // Load scene input handler
        loadSceneInput.addEventListener('change', (e) => {
            if (e.target.files.length === 0) return;

            const files = Array.from(e.target.files);
            const jsonFile = files.find(file => file.name.toLowerCase().endsWith('.json'));
            const imageFiles = files.filter(file => file.type.startsWith('image/'));

            if (!jsonFile) {
                alert('Please select a JSON file along with the images.');
                // Clear the input value to allow reselection
                e.target.value = '';
                return;
            }

            // Clear current scene
            clearScene();

            // Read the JSON file
            const jsonReader = new FileReader();
            jsonReader.onload = (event) => {
                try {
                    const sceneData = JSON.parse(event.target.result);
                    loadScene(sceneData, imageFiles);
                    // Clear the input value after successful loading to allow loading another scene
                    e.target.value = '';
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                    // Clear the input value even on error to allow retry
                    e.target.value = '';
                }
            };
            jsonReader.readAsText(jsonFile);
        });

        // Function to load a scene from JSON data and image files
        function loadScene(sceneData, imageFiles) {
            // Create a map of image files by their base name (without extension)
            const imageMap = {};
            imageFiles.forEach(file => {
                const baseName = file.name.split('.')[0];
                imageMap[baseName] = file;
            });

            // Load grid settings if they exist in the scene data
            if (sceneData.gridAngle !== undefined) {
                updateAngle(sceneData.gridAngle);
            }
            if (sceneData.gridSize !== undefined) {
                updateGridSize(sceneData.gridSize);
            }
            if (sceneData.gridVisible !== undefined) {
                gridCheckbox.checked = sceneData.gridVisible;
                toggleGrid(); // Apply the grid visibility state
            }

            // Load camera/view state if it exists in the scene data
            if (sceneData.camera) {
                if (sceneData.camera.zoomLevel !== undefined) {
                    zoomLevel = sceneData.camera.zoomLevel;
                }
                if (sceneData.camera.offsetX !== undefined) {
                    editorOffsetX = sceneData.camera.offsetX;
                }
                if (sceneData.camera.offsetY !== undefined) {
                    editorOffsetY = sceneData.camera.offsetY;
                }
                // Apply the loaded camera state
                updateEditorPosition();
            }

            // Load tiling sprite if exists
            if (sceneData.tilingSprite) {
                const tilingImageFile = imageFiles.find(file =>
                    file.name.split('.')[0] === sceneData.tilingSprite.type
                );

                if (tilingImageFile) {
                    loadTilingSprite(tilingImageFile, sceneData.tilingSprite);
                } else {
                    console.warn(`Tiling sprite image file not found for type: ${sceneData.tilingSprite.type}`);
                }
            }

            // Load items
            if (sceneData.items) {
                sceneData.items.forEach(itemData => {
                    const imageFile = imageMap[itemData.type];
                    if (imageFile) {
                        loadItem(itemData, imageFile);
                    } else {
                        console.warn(`Image file not found for item type: ${itemData.type}`);
                    }
                });
            }
        }

        // Function to load a tiling sprite
        function loadTilingSprite(imageFile, tilingData) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    console.log('img.naturalWidth', img);

                    // Create a div with the tiled background using the image URL directly
                    const tilingDiv = document.createElement('div');
                    tilingDiv.style.position = 'absolute';
                    tilingDiv.style.left = '0px';
                    tilingDiv.style.top = '0px';
                    tilingDiv.style.width = '100%';
                    tilingDiv.style.height = '100%';
                    tilingDiv.style.backgroundImage = `url(${event.target.result})`;
                    tilingDiv.style.backgroundRepeat = 'repeat';
                    tilingDiv.style.backgroundSize = `${img.naturalWidth}px`;
                    tilingDiv.style.pointerEvents = 'none';
                    tilingDiv.style.zIndex = '1';

                    editor.appendChild(tilingDiv);

                    tilingSprite = {
                        id: tilingData.id,
                        type: tilingData.type,
                        el: tilingDiv,
                        width: tilingData.width,
                        height: tilingData.height,
                        originalSrc: event.target.result
                    };
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(imageFile);
        }

        // Function to load an individual item
        function loadItem(itemData, imageFile) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = document.createElement('img');
                img.src = event.target.result;
                img.className = 'item';

                // Position the item based on the exported data
                // The exported data contains center X and bottom Y coordinates
                img.onload = () => {
                    const imgWidth = img.naturalWidth;
                    const imgHeight = img.naturalHeight;

                    // Calculate left and top positions from center X and bottom Y
                    const leftPos = itemData.x - (imgWidth / 2);
                    const topPos = itemData.y - imgHeight;

                    img.style.left = leftPos + 'px';
                    img.style.top = topPos + 'px';

                    editor.appendChild(img);

                    // Update type counter to match the loaded item's ID
                    if (!typeCounters[itemData.type]) {
                        typeCounters[itemData.type] = 0;
                    }
                    typeCounters[itemData.type] = Math.max(typeCounters[itemData.type], itemData.id);

                    const item = {
                        id: itemData.id,
                        type: itemData.type,
                        x: leftPos,
                        y: topPos,
                        el: img,
                        flipped: itemData.scaleX === -1
                    };

                    // Apply flip transform if item was flipped
                    if (item.flipped) {
                        img.style.transform = 'scaleX(-1)';
                    } else {
                        img.style.transform = 'scaleX(1)';
                    }

                    items.push(item);

                    makeDraggable(img, item);

                    // Update z-indexes after loading
                    updateAllZIndexes();
                };
            };
            reader.readAsDataURL(imageFile);
        }

        function makeDraggable(el, item) {
            let offsetX, offsetY, dragging = false;

            // Prevent default drag behavior on the image
            el.addEventListener('dragstart', (e) => e.preventDefault());
            el.addEventListener('contextmenu', (e) => e.preventDefault());

            // Add hover event listeners for guide lines
            el.addEventListener('mouseenter', () => {
                if (!dragging) {
                    console.log('Showing guide lines for item:', item.id, item.type);
                    hoveredItem = item; // Track hovered item for deletion
                    showGuideLines(item);
                }
            });

            el.addEventListener('mouseleave', () => {
                if (!dragging) {
                    console.log('Hiding guide lines for item:', item.id, item.type);
                    hoveredItem = null; // Clear hovered item
                    hideGuideLines(item);
                }
            });

            el.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Prevent default behavior
                dragging = true;
                const isDuplicating = e.altKey; // Check if Alt key is held

                // Calculate offset using the same coordinate system as mousemove
                const containerRect = editorContainer.getBoundingClientRect();
                const mouseXInContainer = e.clientX - containerRect.left;
                const mouseYInContainer = e.clientY - containerRect.top;

                // Convert to editor coordinates (accounting for pan and zoom)
                const editorMouseX = (mouseXInContainer - editorOffsetX) / zoomLevel;
                const editorMouseY = (mouseYInContainer - editorOffsetY) / zoomLevel;

                // Get current item position
                const currentX = parseFloat(el.style.left) || 0;
                const currentY = parseFloat(el.style.top) || 0;

                // Calculate offset between mouse and item position
                offsetX = editorMouseX - currentX;
                offsetY = editorMouseY - currentY;

                let currentEl = el;
                let currentItem = item;

                if (isDuplicating) {
                    // Create a duplicate
                    const newImg = el.cloneNode(true);
                    newImg.style.left = el.style.left;
                    newImg.style.top = el.style.top;
                    newImg.style.opacity = '0.8';
                    editor.appendChild(newImg);

                    // Create new item data with proper type-based id and preserve flip state
                    typeCounters[item.type]++;
                    const newId = typeCounters[item.type];
                    const duplicatedItem = { id: newId, type: item.type, x: item.x, y: item.y, el: newImg, flipped: item.flipped };

                    // Apply flip transform if original was flipped
                    if (item.flipped) {
                        newImg.style.transform = 'scaleX(-1)';
                    } else {
                        newImg.style.transform = 'scaleX(1)';
                    }

                    items.push(duplicatedItem);

                    // Make the duplicate draggable
                    makeDraggable(newImg, duplicatedItem);

                    // We'll be dragging the duplicate, not the original
                    currentEl = newImg;
                    currentItem = duplicatedItem;

                    // Update z-indexes after duplication
                    updateAllZIndexes();
                } else {
                    // Add visual feedback for normal drag
                    el.style.opacity = '0.8';
                }

                // Handle mouse move for this specific drag operation
                const handleMouseMove = (e) => {
                    if (!dragging) return;
                    e.preventDefault();

                    // Convert mouse position to editor coordinate system accounting for zoom
                    const containerRect = editorContainer.getBoundingClientRect();
                    const mouseXInContainer = e.clientX - containerRect.left;
                    const mouseYInContainer = e.clientY - containerRect.top;

                    // Convert to editor coordinates (accounting for pan and zoom)
                    const editorX = (mouseXInContainer - editorOffsetX) / zoomLevel;
                    const editorY = (mouseYInContainer - editorOffsetY) / zoomLevel;

                    // Apply the offset that was captured on mousedown
                    let x = editorX - offsetX;
                    let y = editorY - offsetY;

                    currentEl.style.left = x + 'px';
                    currentEl.style.top = y + 'px';
                    currentItem.x = x;
                    currentItem.y = y;

                    // Update guide lines position during drag
                    const leftLine = document.getElementById(`guide-left-${currentItem.id}-${currentItem.type}`);
                    const rightLine = document.getElementById(`guide-right-${currentItem.id}-${currentItem.type}`);
                    if (leftLine && rightLine && (leftLine.style.display === 'block' || rightLine.style.display === 'block')) {
                        positionGuideLines(currentItem, { left: leftLine, right: rightLine });
                    }

                    // Update z-indexes during drag to maintain proper layering
                    updateAllZIndexes();
                };

                // Handle mouse up for this specific drag operation
                const handleMouseUp = (e) => {
                    if (dragging) {
                        e.preventDefault();
                        dragging = false;

                        // Reset visual feedback
                        currentEl.style.opacity = '1';

                        // Final z-index update after drag completes
                        updateAllZIndexes();

                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                };

                // Add event listeners for this drag operation
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
        }

        // Function to create the grid element
        function createGrid() {
            if (gridElement) {
                gridElement.remove();
            }

            // Create SVG element for the grid
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.left = '0px';
            svg.style.top = '0px';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '10'; // Above tiling background (which is 1), below items
            svg.style.display = 'none';

            // Create the grid lines directly without patterns
            const gridSpacing = gridSize; // Use configurable grid size
            const viewportWidth = window.innerWidth * 10;
            const viewportHeight = window.innerHeight * 10;
            const maxDimension = Math.max(viewportWidth, viewportHeight);
            const lineExtent = maxDimension * 1.5; // Lines extend 1.5x the viewport size

            // Convert angle to radians for calculations
            // Guide lines are vertical lines rotated by the angle
            const leftAngleRad = (-guideLineAngle) * Math.PI / 180; // Left guide line angle
            const rightAngleRad = guideLineAngle * Math.PI / 180; // Right guide line angle

            // Calculate how many lines we need (reduced from previous implementation)
            const numLines = Math.ceil(maxDimension / gridSpacing);

            // Get the center of the viewport
            const centerX = viewportWidth / 2;
            const centerY = viewportHeight / 2;

            const lineWidth = 1;
            const lineColor = 'rgba(0, 0, 255, 0.35)';

            // Create left-angled lines (matching left guide line)
            for (let i = -numLines; i <= numLines; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                // For a rotated vertical line, the direction vector is (sin(angle), cos(angle))
                const dirX = Math.sin(leftAngleRad);
                const dirY = Math.cos(leftAngleRad);

                // Perpendicular direction for spacing lines apart
                const perpX = -dirY;
                const perpY = dirX;

                // Calculate offset for this line
                const offsetDistance = i * gridSpacing;
                const offsetX = offsetDistance * perpX;
                const offsetY = offsetDistance * perpY;

                // Line extends from center + offset in both directions along the direction
                const startX = centerX + offsetX - lineExtent * dirX;
                const startY = centerY + offsetY - lineExtent * dirY;
                const endX = centerX + offsetX + lineExtent * dirX;
                const endY = centerY + offsetY + lineExtent * dirY;

                line.setAttribute('x1', startX.toString());
                line.setAttribute('y1', startY.toString());
                line.setAttribute('x2', endX.toString());
                line.setAttribute('y2', endY.toString());
                line.setAttribute('stroke', lineColor);
                line.setAttribute('stroke-width', lineWidth);

                svg.appendChild(line);
            }

            // Create right-angled lines (matching right guide line)
            for (let i = -numLines; i <= numLines; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                // For a rotated vertical line, the direction vector is (sin(angle), cos(angle))
                const dirX = Math.sin(rightAngleRad);
                const dirY = Math.cos(rightAngleRad);

                // Perpendicular direction for spacing lines apart
                const perpX = -dirY;
                const perpY = dirX;

                // Calculate offset for this line
                const offsetDistance = i * gridSpacing;
                const offsetX = offsetDistance * perpX;
                const offsetY = offsetDistance * perpY;

                // Line extends from center + offset in both directions along the direction
                const startX = centerX + offsetX - lineExtent * dirX;
                const startY = centerY + offsetY - lineExtent * dirY;
                const endX = centerX + offsetX + lineExtent * dirX;
                const endY = centerY + offsetY + lineExtent * dirY;

                line.setAttribute('x1', startX.toString());
                line.setAttribute('y1', startY.toString());
                line.setAttribute('x2', endX.toString());
                line.setAttribute('y2', endY.toString());
                line.setAttribute('stroke', lineColor);
                line.setAttribute('stroke-width', lineWidth);

                svg.appendChild(line);
            }

            editor.appendChild(svg);
            gridElement = svg;
        }

        // Function to update grid angle
        function updateGridAngle() {
            // Recreate the grid with new angles
            if (gridCheckbox.checked && gridElement) {
                const wasVisible = gridElement.style.display !== 'none';
                createGrid();
                if (wasVisible) {
                    gridElement.style.display = 'block';
                }
            }
        }

        // Function to toggle grid visibility
        function toggleGrid() {
            if (!gridElement) {
                createGrid();
            }

            if (gridCheckbox.checked) {
                gridElement.style.display = 'block';
            } else {
                gridElement.style.display = 'none';
            }
        }

        // Function to update all existing guide lines with new angle
        function updateAllGuideLineAngles() {
            items.forEach(item => {
                const leftLine = document.getElementById(`guide-left-${item.id}-${item.type}`);
                const rightLine = document.getElementById(`guide-right-${item.id}-${item.type}`);

                if (leftLine) {
                    leftLine.style.transform = `rotate(${-guideLineAngle}deg)`;
                }
                if (rightLine) {
                    rightLine.style.transform = `rotate(${guideLineAngle}deg)`;
                }
            });
        }

        // Function to update angle and sync both inputs
        function updateAngle(newAngle) {
            guideLineAngle = Number(newAngle);
            angleSlider.value = guideLineAngle;
            angleInput.value = guideLineAngle;
            updateAllGuideLineAngles();
            updateGridAngle();
        }

        // Function to update grid size and sync both inputs
        function updateGridSize(newSize) {
            gridSize = Number(newSize);
            gridSizeSlider.value = gridSize;
            gridSizeInput.value = gridSize;
            updateGridAngle(); // Recreate grid with new size
        }

        // Angle slider event listener
        angleSlider.addEventListener('input', (e) => {
            updateAngle(e.target.value);
        });

        // Angle text input event listener
        angleInput.addEventListener('input', (e) => {
            const value = Number(e.target.value);
            if (!isNaN(value) && value >= 45 && value <= 90) {
                updateAngle(value);
            }
        });

        // Handle invalid input on blur - reset to current valid value
        angleInput.addEventListener('blur', (e) => {
            const value = Number(e.target.value);
            if (isNaN(value) || value < 45 || value > 90) {
                angleInput.value = guideLineAngle;
            }
        });

        // Grid size slider event listener
        gridSizeSlider.addEventListener('input', (e) => {
            updateGridSize(e.target.value);
        });

        // Grid size text input event listener
        gridSizeInput.addEventListener('input', (e) => {
            const value = Number(e.target.value);
            if (!isNaN(value) && value >= 40 && value <= 120) {
                updateGridSize(value);
            }
        });

        // Handle invalid grid size input on blur - reset to current valid value
        gridSizeInput.addEventListener('blur', (e) => {
            const value = Number(e.target.value);
            if (isNaN(value) || value < 40 || value > 120) {
                gridSizeInput.value = gridSize;
            }
        });

        // Grid checkbox event listener
        gridCheckbox.addEventListener('change', toggleGrid);

        exportBtn.addEventListener('click', () => {
            console.log('Export started. Items count:', items.length);
            console.log('Tiling sprite exists:', !!tilingSprite);

            const itemsData = items.map(i => {
                // Use actual position values from editor coordinates (not affected by zoom/transform)
                const itemX = parseFloat(i.el.style.left) || 0;
                const itemY = parseFloat(i.el.style.top) || 0;
                const itemWidth = i.el.offsetWidth;
                const itemHeight = i.el.offsetHeight;

                // Calculate center X and bottom Y in editor coordinates
                const centerX = itemX + itemWidth / 2;
                const bottomY = itemY + itemHeight;

                const itemData = { id: i.id, type: i.type, x: centerX, y: bottomY };

                // Include scaleX if item is flipped
                if (i.flipped) {
                    itemData.scaleX = -1;
                }

                return itemData;
            });

            console.log('Exported items data:', itemsData);

            const exportData = {
                items: itemsData,
                tilingSprite: tilingSprite ? {
                    id: tilingSprite.id,
                    type: tilingSprite.type,
                    width: tilingSprite.width,
                    height: tilingSprite.height
                } : null,
                gridAngle: guideLineAngle,
                gridSize: gridSize,
                gridVisible: gridCheckbox.checked,
                // Save camera/view state
                camera: {
                    zoomLevel: zoomLevel,
                    offsetX: editorOffsetX,
                    offsetY: editorOffsetY
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            window.open(URL.createObjectURL(blob), '_blank');




            setTimeout(() => {


                URL.revokeObjectURL(a.href);
            }, 100);

            console.log('Export completed successfully');
        });
    </script>

</body>
</html>